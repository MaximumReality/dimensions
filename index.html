<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Maximum Reality: Matrix Infinity</title>
    <style>
        :root { --glitch-color: rgba(0, 255, 255, 0.05); }
        body, html { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            overflow: hidden; background: #000;
            -webkit-user-select: none; touch-action: none;
        }
        #gameCanvas { display: block; width: 100vw; height: 100vh; image-rendering: pixelated; }
        .ui-layer {
            position: absolute; top: env(safe-area-inset-top); left: 20px;
            color: #0ff; font-family: 'Courier New', monospace;
            z-index: 100; pointer-events: none; text-shadow: 0 0 8px #0ff;
        }
        #bsod {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #0000aa; color: #fff; font-family: 'Courier New';
            display: none; z-index: 200; padding: 50px; box-sizing: border-box;
        }
    </style>
</head>
<body>
    <div id="bsod">
        <h1>:(</h1>
        <p>A problem has been detected and the simulation has been shut down.</p>
        <p>ERROR: KERNEL_DATA_INPAGE_ERROR (old-pc.png)</p>
        <p>REBOOTING REALITY...</p>
    </div>
    <div class="ui-layer">
        <div id="score">DIMENSION: 0</div>
        <div id="status">INJECTING CODE...</div>
    </div>
    <canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const bgMusic = new Audio('password-infinity.mp3');
bgMusic.loop = true;
bgMusic.addEventListener('ended', () => { bgMusic.currentTime = 0; bgMusic.play(); });

const GROUND_Y_OFFSET = 100; 
let floorY;

const ASSETS = {
    bg: 'gg-bg.png',
    floor: 'floor.png',
    azul: ['Azul-doll.png', 'Azul-doll2.png', 'Azul-doll3.png', 'Azul-doll4.png'],
    buildings: ['building-a.png', 'building-b.png', 'building-c.png'],
    loriBlur: 'lori-blur.png',
    obstacles: ['old-pc.png']
};

const TECH_GEAR = ["üíª", "‚å®Ô∏è", "üíø", "üíæ", "üíΩ"];
const MATRIX_CHARS = "0123456789ABCDEF01";

let gameState = 'START', score = 0, frame = 0, gameSpeed = 7;
let jumpHeight = 0, yVelocity = 0, shake = 0, dimensionHue = 0;
const gravity = 1.2, imgCache = {};

// --- üü¢ ADDED: MATRIX ENGINE ---
let columns;
let drops = [];
function initMatrix() {
    columns = Math.floor(canvas.width / 20);
    drops = Array(columns).fill(1);
}

function drawMatrix() {
    ctx.save();
    
    // 1. Set the color to a bright, classic Matrix Green (or your dimension hue)
    // Increased alpha to 0.8 for high visibility
    ctx.fillStyle = `hsla(${dimensionHue + 120}, 100%, 50%, 0.8)`;
    
    // 2. Add a neon glow effect
    ctx.shadowBlur = 8;
    ctx.shadowColor = `hsla(${dimensionHue + 120}, 100%, 50%, 1)`;
    
    ctx.font = "bold 18px monospace"; // Bolded and slightly larger
    
    for (let i = 0; i < drops.length; i++) {
        const text = MATRIX_CHARS[Math.floor(Math.random() * MATRIX_CHARS.length)];
        
        // Render the character
        ctx.fillText(text, i * 20, drops[i] * 20);
        
        // Reset drop if it hits the floor or randomly
        if (drops[i] * 20 > canvas.height && Math.random() > 0.975) {
            drops[i] = 0;
        }
        
        // The speed of the fall
        drops[i]++;
    }
    ctx.restore();
}


// --- üü¢ ADDED: LOAD ENGINE ---
function load() {
    Object.keys(ASSETS).forEach(key => {
        if (Array.isArray(ASSETS[key])) {
            imgCache[key] = ASSETS[key].map(src => { let i = new Image(); i.src = src; return i; });
        } else {
            imgCache[key] = new Image(); imgCache[key].src = ASSETS[key];
        }
    });
}

load();

function resize() { 
    canvas.width = window.innerWidth; 
    canvas.height = window.innerHeight;
    floorY = canvas.height - GROUND_Y_OFFSET;
    initMatrix();
}
window.addEventListener('resize', resize); resize();

let gameObjects = [], backgroundProps = [];

function spawn() {
    if (Math.random() > 0.993) {
        backgroundProps.push({ x: canvas.width + 200, y: floorY - 350, w: 220, h: 350, passed: false });
    }
    if (frame % 85 === 0) {
        const isTech = Math.random() > 0.5;
        gameObjects.push({
            x: canvas.width + 100, y: floorY - 80, w: 90, h: 80,
            type: isTech ? 'tech' : 'obstacle',
            emoji: isTech ? TECH_GEAR[Math.floor(Math.random() * TECH_GEAR.length)] : null,
            img: isTech ? null : imgCache.obstacles[0]
        });
    }
}

function triggerBSOD() {
    gameState = 'GAMEOVER';
    bgMusic.pause();
    document.getElementById('bsod').style.display = 'block';
    setTimeout(() => { document.getElementById('bsod').style.display = 'none'; }, 2000);
}

function draw() {
    // 1. THE BASE
    if (imgCache.bg.complete) ctx.drawImage(imgCache.bg, 0, 0, canvas.width, canvas.height);
    
    // 2. THE BUILDINGS
    const layers = [
        {img: imgCache.buildings[2], s: 0.5, op: 0.2, h: 550}, 
        {img: imgCache.buildings[1], s: 1.5, op: 0.4, h: 450}, 
        {img: imgCache.buildings[0], s: 3, op: 0.6, h: 350}
    ];
    layers.forEach(l => {
        if (l.img.complete) {
            ctx.save();
            let x = -(frame * l.s) % canvas.width;
            ctx.globalAlpha = l.op;
            ctx.filter = `hue-rotate(${dimensionHue}deg) brightness(1.2)`;
            ctx.drawImage(l.img, x, floorY - l.h, canvas.width, l.h);
            ctx.drawImage(l.img, x + canvas.width, floorY - l.h, canvas.width, l.h);
            ctx.restore();
        }
    });

    // 3. THE MATRIX RAIN (Now visible over buildings!)
    ctx.globalCompositeOperation = "screen"; 
    drawMatrix();
    ctx.globalCompositeOperation = "source-over"; 

    // 4. THE GHOST
    backgroundProps.forEach((p, i) => {
        p.x -= 4; 
        if (imgCache.loriBlur.complete) {
            ctx.save(); ctx.globalAlpha = 0.5;
            ctx.drawImage(imgCache.loriBlur, p.x, p.y, p.w, p.h);
            ctx.restore();
        }
        if (!p.passed && p.x < 150) {
            p.passed = true; shake = 25; dimensionHue += 90;
        }
        if (p.x < -350) backgroundProps.splice(i, 1);
    });

    // 5. THE FLOOR
    if (imgCache.floor.complete) {
        let fX = -(frame * gameSpeed) % 100;
        for (let i = -1; i < (canvas.width / 100) + 2; i++) {
            ctx.drawImage(imgCache.floor, (i * 100) + fX, floorY, 100, GROUND_Y_OFFSET);
        }
    }
}

function loop() {
    ctx.save();
    if (shake > 0) { ctx.translate(Math.random()*shake, Math.random()*shake); shake *= 0.85; }
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    draw();

    if (gameState === 'PLAYING') {
        frame++; spawn();
        jumpHeight -= yVelocity; yVelocity += gravity;
        if (jumpHeight <= 0) { jumpHeight = 0; yVelocity = 0; }

        const aFrame = Math.floor(frame / 6) % 4;
        if (imgCache.azul[aFrame].complete) {
            ctx.drawImage(imgCache.azul[aFrame], 100, floorY - 110 - jumpHeight, 90, 115);
        }

        gameObjects.forEach((obj, i) => {
            obj.x -= gameSpeed;
            if (obj.x < 160 && obj.x > 80 && jumpHeight < 55) {
                if (obj.type === 'tech') { score += 100; gameObjects.splice(i, 1); }
                else { triggerBSOD(); }
            }
            if (obj.type === 'tech') {
                ctx.font = "40px Arial";
                ctx.fillText(obj.emoji, obj.x, obj.y + 40);
            } else if (obj.img && obj.img.complete) {
                ctx.save();
                if (Math.random() > 0.9) ctx.filter = "brightness(2)";
                ctx.drawImage(obj.img, obj.x, obj.y, obj.w, obj.h);
                ctx.restore();
            }
            if (obj.x < -100) gameObjects.splice(i, 1);
        });
        document.getElementById('score').innerText = `DIMENSION: ${score}`;
    } else {
        ctx.fillStyle = "rgba(0,0,0,0.85)"; ctx.fillRect(0,0,canvas.width, canvas.height);
        ctx.fillStyle = "#0ff"; ctx.textAlign = "center"; ctx.font = "18px Courier";
        ctx.fillText(gameState === 'START' ? "TAP TO INJECT CODE" : "REBOOTING...", canvas.width/2, canvas.height/2);
    }
    ctx.restore();
    requestAnimationFrame(loop);
}

window.addEventListener('touchstart', (e) => {
    if (gameState !== 'PLAYING') {
        gameState = 'PLAYING'; score = 0; frame = 0; gameObjects = []; backgroundProps = [];
        dimensionHue = 0; bgMusic.play();
    } else if (jumpHeight === 0) yVelocity = -22;
    e.preventDefault();
}, {passive: false});

loop();
</script>

</body>
</html>
