<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">

  <title>Maximum Reality: Dimensions</title>
  <meta name="description" content="Maximum Reality: Dimensions â€” a neon cyber arcade experience. Dodge obstacles, collect loot, and survive in multiple realities!">

  <!-- Favicon & Touch Icons -->
  <link rel="icon" type="image/png" sizes="16x16" href="https://maximumreality.github.io/dimensions/Banner-16.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://maximumreality.github.io/dimensions/Banner-32.png">
  <link rel="icon" type="image/png" sizes="48x48" href="https://maximumreality.github.io/dimensions/Banner-48.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://maximumreality.github.io/dimensions/Banner-180.png">

  <!-- Manifest for PWA -->
  <link rel="manifest" href="manifest.json">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- Open Graph / Social Sharing -->
  <meta property="og:title" content="Maximum Reality: Dimensions">
  <meta property="og:description" content="A neon cyber arcade experience. Dodge obstacles, collect loot, and survive in multiple realities!">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://maximumreality.github.io/dimensions/">
  <meta property="og:image" content="https://maximumreality.github.io/dimensions/Banner-180.png">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Maximum Reality: Dimensions">
  <meta name="twitter:description" content="A neon cyber arcade experience. Dodge obstacles, collect loot, and survive in multiple realities!">
  <meta name="twitter:image" content="https://maximumreality.github.io/dimensions/Banner-180.png">

  <!-- Style / Animations -->
  <style>
    body, html {
      margin:0; padding:0; width:100%; height:100%; overflow:hidden;
      background:#000; -webkit-user-select:none; touch-action:none;
      font-family: 'Courier New', monospace;
    }
    #gameCanvas { display:block; width:100vw; height:100vh; background:#000; }

    .ui-layer { position: absolute; top: env(safe-area-inset-top); left: 20px;
      color: #0ff; z-index: 100; pointer-events: none; text-shadow: 0 0 8px #0ff; }
    #score { font-size: 24px; font-weight: bold; }
    #highScore { font-size: 14px; opacity: 0.8; margin-top: 5px; }
    #status { font-size: 16px; margin-top: 8px; }

    .controls { position: absolute; top: calc(env(safe-area-inset-top) + 30px); right: 20px;
      display: flex; gap: 15px; z-index: 150; }
    .btn { font-size: 24px; background: rgba(0,255,255,0.15); border: 1.5px solid #0ff;
      border-radius: 8px; padding: 8px 12px; color: #0ff; cursor: pointer;
      backdrop-filter: blur(5px); display: flex; align-items: center; justify-content: center;
      user-select: none; touch-action: manipulation; }

    #bsod { position: fixed; inset: 0; background: #0000aa; color: #fff;
      font-family: 'Courier New'; display: none; z-index: 200; padding: 50px; text-align: center; }

    #flash { position: fixed; inset: 0; background: #fff; opacity: 0; z-index: 250;
      pointer-events: none; transition: opacity 0.1s; }

    #startOverlay {
      position: fixed; inset: 0; z-index: 300; display: flex; align-items: center; justify-content: center;
      color: #0ff; font-size: 48px; text-shadow: 0 0 15px #0ff;
      pointer-events: auto !important; background: rgba(0,0,0,0.85);
    }

    #hardModeBtn { text-shadow: 0 0 10px #f0f; animation: pulse 1.5s infinite; }
    #easyModeBtn { text-shadow: 0 0 10px #0ff; }

    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
  </style>
</head>
<body>

<div id="bsod">
  <h1>:(</h1>
  <p>CRITICAL DIMENSION ERROR</p>
  <p>REBOOTING SIMULATION...</p>
</div>

<div id="flash"></div>

<div id="startOverlay">
  <div style="text-align: center;">
    <div style="font-size: 32px; margin-bottom: 30px;">CHOOSE REALITY</div>
    <div style="display: flex; gap: 20px; justify-content: center;">
      <div id="hardModeBtn" class="btn" style="border-color: #f0f; color: #f0f;">CHAOS</div>
      <div id="easyModeBtn" class="btn" style="border-color: #0ff; color: #0ff;">COMFORT</div>
    </div>
    
    <img src="worse.png" style="width: 120px; margin-top: 40px; opacity: 0.8; filter: drop-shadow(0 0 10px #f0f);">
  </div>
</div>


<div class="controls">
  <a href="https://maximumreality.xyz" class="btn">ğŸ </a>
  <div id="muteBtn"  class="btn">ğŸ”Š</div>
  <div id="pauseBtn" class="btn">â¯ï¸</div>
</div>

<div class="ui-layer">
  <div id="score">DIMENSION: 0</div>
  <div id="highScore">BEST: 0</div>
  <div id="status">ZONE: CYBER</div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  CORE SETUP
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const canvas = document.getElementById('gameCanvas');
const ctx    = canvas.getContext('2d');

const bgMusic       = new Audio('password-infinity.mp3'); bgMusic.loop = true;
const beastModeSfx  = new Audio('beast_mode.mp3');

let isMuted       = false;
let isPaused      = false;
let gameState     = 'START'; // START | PLAYING | GAMEOVER
let score         = 0;
let highScore     = Number(localStorage.getItem('maxRealityHighScore')) || 0;
let frame         = 0;
let gameSpeed     = 7;
let dimensionHue    = 0;
let jumpHeight      = 0;
let yVelocity       = 0;
let jumpsUsed       = 0; // <--- Add this
let shake           = 0;

let bonusCount    = 0;
let currentZone   = 'CYBER';
let portalActive  = false;
let beastModePlayed = false;
let lastPortalScore = 0;

const gravity       = 1.2;
const GROUND_Y_OFFSET = 100;
let floorY;

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  ASSETS & LOOT TABLES
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Add the 'pc' key here so it's managed like everything else
const ASSETS = {
  bg:             'gg-bg.png',
  snackBg:        'hot-food-c-store-wp.JPG',
  earthquakeBg:   'pompeii-bg.png',
  floor:          'floor.png',
  loriBlur:       'lori-blur.png',
  portal:         'snack-portal.png',
  pc:             'old-pc.png',          // â† Added!
  azul:           ['Azul-doll.png','Azul-doll2.png','Azul-doll3.png','Azul-doll4.png'],
  buildings:      ['building-a.png','building-b.png','building-c.png'],
};

const CYBER_LOOT       = ['2tb.png','card.png','circuitpython.png','core-i7.png','core-i9.png','cpu-water-cooler.png','curve-keyboard.png','graphics-card.png','motherboard.png','optical-drive.png','power-supply.png','ram.png','ssd.png'];
const SNACK_LOOT       = ['azulo_blueberry_vanilla.jpg','bread-slice.png','chips.png','hotdog.png','mochkil-burger.png','mochkil_puffs_orange.png','pink-donut.png','roast-chicken.png','soda.png','taco.png'];
const EARTHQUAKE_LOOT  = ['book.png','scrolls.png','pottery.png','pottery2.png','pottery3.png','pottery4.png'];
const EARTHQUAKE_OBSTACLES = ['herc-bust.png','rubble.png'];

// This updated cache structure keeps everything organized
const imgCache = {
  bg: null,
  snackBg: null,
  earthquakeBg: null,
  floor: null,
  loriBlur: null,
  portal: null,
  pc: null,
  azul: [],
  buildings: [],
  CYBER_LOOT: [],
  SNACK_LOOT: [],
  EARTHQUAKE_LOOT: [],
  EARTHQUAKE_OBSTACLES: []
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  LOAD ASSETS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function loadAssets() {
  // 1. Load Single Images
  ['bg','snackBg','earthquakeBg','floor','loriBlur','portal','pc'].forEach(key => {
    const img = new Image();
    img.src = ASSETS[key];
    imgCache[key] = img; 
  });

  // 2. Load Arrays (Azul & Buildings)
  ASSETS.azul.forEach(src => {
    const img = new Image(); img.src = src;
    imgCache.azul.push(img);
  });
  ASSETS.buildings.forEach(src => {
    const img = new Image(); img.src = src;
    imgCache.buildings.push(img);
  });

  // 3. Load Loot Tables
  CYBER_LOOT.forEach(src => { const i = new Image(); i.src = src; imgCache.CYBER_LOOT.push(i); });
  SNACK_LOOT.forEach(src => { const i = new Image(); i.src = src; imgCache.SNACK_LOOT.push(i); });
  EARTHQUAKE_LOOT.forEach(src => { const i = new Image(); i.src = src; imgCache.EARTHQUAKE_LOOT.push(i); });
  EARTHQUAKE_OBSTACLES.forEach(src => { const i = new Image(); i.src = src; imgCache.EARTHQUAKE_OBSTACLES.push(i); });
}
loadAssets();

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  MATRIX RAIN (cyber background)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

let drops = [];
function initMatrix() {
  drops = Array(Math.floor(canvas.width / 20)).fill(1);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  RESIZE & INIT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  floorY = canvas.height - GROUND_Y_OFFSET;
  initMatrix();
}
resize();
window.addEventListener('resize', resize);

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  CONTROLS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

document.getElementById('muteBtn').addEventListener('touchstart', e => {
  e.stopPropagation();
  isMuted = !isMuted;
  bgMusic.muted = isMuted;
  beastModeSfx.muted = isMuted;
  document.getElementById('muteBtn').innerText = isMuted ? 'ğŸ”‡' : 'ğŸ”Š';
}, {passive: false});

document.getElementById('pauseBtn').addEventListener('touchstart', e => {
  e.stopPropagation();
  isPaused = !isPaused;
  document.getElementById('pauseBtn').style.borderColor = isPaused ? '#ff0' : '#0ff';
}, {passive: false});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  GAME STATE MACHINES
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function triggerBSOD() {
  gameState = 'GAMEOVER';
  bgMusic.pause();
  if (score > highScore) {
    highScore = score;
    localStorage.setItem('maxRealityHighScore', highScore);
  }
  document.getElementById('bsod').style.display = 'block';
  setTimeout(() => {
    document.getElementById('bsod').style.display = 'none';
    resetGame();
    gameState = 'START';
    document.getElementById('startOverlay').style.display = 'flex';
  }, 2200);
}

function resetGame() {
  score = 0;
  frame = 0;
  jumpHeight = 0;
  yVelocity = 0;
  shake = 0;
  bonusCount = 0;
  gameObjects = [];
  portalActive = false;
  beastModePlayed = false;
  lastPortalScore = 0;
  particles = [];
  currentZone = 'CYBER';
  gameSpeed = 7;
  dimensionHue = 0;
}

function flashScreen() {
  const f = document.getElementById('flash');
  f.style.opacity = 1;
  setTimeout(() => f.style.opacity = 0, 100);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  SPAWN LOGIC
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

let gameObjects = [];
let particles = [];

class Particle {
  constructor(x, y, color, text = null, sizeMod = 1) {
    this.x = x; this.y = y;
    this.char = text || (Math.random() > 0.5 ? "0" : "1");
    this.size = (text ? 28 : Math.random() * 10 + 12) * sizeMod;
    this.speedX = (Math.random() - 0.5) * 10;
    this.speedY = (Math.random() - 0.5) * 10;
    this.color = color; this.life = 1.0;
  }
  update() { this.x += this.speedX; this.y += this.speedY; this.life -= 0.02; }
  draw() {
    ctx.save();
    ctx.fillStyle = this.color;
    ctx.globalAlpha = this.life;
    ctx.font = `bold ${this.size}px monospace`;
    ctx.fillText(this.char, this.x, this.y);
    ctx.restore();
  }
}

function spawn() {
  // PORTAL LOGIC (Every 5000 pts)
  if (score >= 5000 && score - lastPortalScore >= 5000 && !portalActive) {
    portalActive = true;
    lastPortalScore = score;
    gameObjects.push({
      x: canvas.width + 100,
      y: floorY - 140,
      w: 120, h: 140,
      type: 'portal',
      img: imgCache.portal
    });
    return;
  }

  // LOOT SPAWN
  let lootArr = (currentZone === 'CYBER') ? imgCache.CYBER_LOOT : 
                (currentZone === 'SNACK') ? imgCache.SNACK_LOOT : imgCache.EARTHQUAKE_LOOT;

  if (frame % 80 === 0 && lootArr.length > 0) {
    gameObjects.push({
      x: canvas.width + 100, y: floorY - 85,
      w: 80, h: 80, type: 'tech',
      img: lootArr[Math.floor(Math.random() * lootArr.length)]
    });
  }

  // OBSTACLE SPAWN (Fixed for performance)
  if (frame % 180 === 0) {
    let obsImg = null;
    
    if (currentZone === 'CYBER') {
      obsImg = imgCache.pc; // Using the cached PC image
    } else if (currentZone === 'EARTHQUAKE') {
      obsImg = imgCache.EARTHQUAKE_OBSTACLES[Math.floor(Math.random() * imgCache.EARTHQUAKE_OBSTACLES.length)];
    }

    if (obsImg) {
      gameObjects.push({
        x: canvas.width + 100, y: floorY - 90,
        w: 80, h: 80, type: 'obstacle',
        img: obsImg
      });
    }
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  BACKGROUND RENDERING
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function drawBackground() {
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  if (currentZone === 'SNACK' && imgCache.snackBg?.complete) {
    const x = -((frame * 2) % canvas.width);
    ctx.drawImage(imgCache.snackBg, x, 0, canvas.width, canvas.height);
    ctx.drawImage(imgCache.snackBg, x + canvas.width, 0, canvas.width, canvas.height);
  }
  else if (currentZone === 'EARTHQUAKE' && imgCache.earthquakeBg?.complete) {
    const x = -((frame * 1.5) % canvas.width);
    ctx.drawImage(imgCache.earthquakeBg, x, 0, canvas.width, canvas.height);
    ctx.drawImage(imgCache.earthquakeBg, x + canvas.width, 0, canvas.width, canvas.height);
  }
  else { // CYBER
    if (imgCache.bg?.complete) {
      ctx.drawImage(imgCache.bg, 0, 0, canvas.width, canvas.height);
    }
    if (imgCache.loriBlur?.complete) {
      ctx.save();
      ctx.globalAlpha = 0.4;
      const lX = -((frame * 0.5) % canvas.width);
      ctx.drawImage(imgCache.loriBlur, lX, 0, canvas.width, canvas.height);
      ctx.drawImage(imgCache.loriBlur, lX + canvas.width, 0, canvas.width, canvas.height);
      ctx.restore();
    }

    // Parallax buildings
    const layers = [
      {img: imgCache.buildings[2], speed: 0.8,  opacity: 0.2, height: 550},
      {img: imgCache.buildings[1], speed: 1.8,  opacity: 0.4, height: 450},
      {img: imgCache.buildings[0], speed: 3.5,  opacity: 0.6, height: 350}
    ];
    layers.forEach(l => {
      if (l.img?.complete) {
        ctx.save();
        const x = -((frame * l.speed) % canvas.width);
        ctx.globalAlpha = l.opacity;
        ctx.filter = `hue-rotate(${dimensionHue}deg)`;
        ctx.drawImage(l.img, x, floorY - l.height, canvas.width, l.height);
        ctx.drawImage(l.img, x + canvas.width, floorY - l.height, canvas.width, l.height);
        ctx.restore();
      }
    });

    // Matrix rain
    ctx.save();
    ctx.fillStyle = `hsl(${dimensionHue}, 100%, 60%)`;
    ctx.font = "bold 18px monospace";
    drops.forEach((y, i) => {
      ctx.fillText(Math.random() > 0.5 ? "1" : "0", i * 20, y * 20);
      if (y * 20 > canvas.height && Math.random() > 0.975) drops[i] = 0;
      drops[i]++;
    });
    ctx.restore();
  }

  // Ground
  ctx.fillStyle = currentZone === 'EARTHQUAKE' ? '#440' : "#222";
  ctx.fillRect(0, floorY, canvas.width, GROUND_Y_OFFSET);

  if (imgCache.floor?.complete) {
    const fX = -((frame * gameSpeed) % 100);
    for (let i = -1; i < (canvas.width / 100) + 2; i++) {
      ctx.drawImage(imgCache.floor, (i * 100) + fX, floorY, 100, GROUND_Y_OFFSET);
    }
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  MAIN GAME LOOP
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function loop() {
  if (isPaused) {
    requestAnimationFrame(loop);
    return;
  }

  ctx.save();

  // Screen shake
  if (shake > 0) {
    ctx.translate((Math.random() - 0.5) * shake, (Math.random() - 0.5) * shake);
    shake *= 0.88;
    if (shake < 0.2) shake = 0;
  }

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  drawBackground();

  // Particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.update();
    p.draw();
    if (p.life <= 0) particles.splice(i, 1);
  }

  if (gameState === 'PLAYING') {
    frame++;
    spawn();

        // Player physics
    jumpHeight -= yVelocity;
    yVelocity += gravity;
    let landed = false;
    if (jumpHeight <= 0) {
      jumpHeight = 0;
      if (yVelocity > 0) {
          landed = true;
          jumpsUsed = 0; // <--- Reset jumps here
      }
      yVelocity = 0;
    }

    if (currentZone === 'CYBER' && landed && beastModePlayed) shake = Math.max(shake, 5);
    if (currentZone === 'EARTHQUAKE') shake = Math.max(shake, 15);

    // Draw Azul
    const animFrame = Math.floor(frame / 6) % 4;
    if (imgCache.azul[animFrame]?.complete) {
      ctx.drawImage(imgCache.azul[animFrame], 100, floorY - 110 - jumpHeight, 90, 115);
    }

    // â”€â”€â”€ Objects (reverse loop = safe removal) â”€â”€â”€
    // â”€â”€â”€ Objects (reverse loop = safe removal) â”€â”€â”€
for (let i = gameObjects.length - 1; i >= 0; i--) {
  const obj = gameObjects[i];
  obj.x -= gameSpeed;

  // Player hitbox (slightly smaller than visual sprite for better feel)
    const player = {
    x: 100,
    y: floorY - 110 - jumpHeight, // This keeps the hitbox glued to Azul's feet
    width: 70,      
    height: 110     
  };


  // Object hitbox (with adjustable padding/grace area)
  const padding = 8; // smaller = stricter collision, larger = more forgiving
  const objHitbox = {
    x: obj.x + padding,
    y: obj.y + padding,
    width: obj.w - padding * 2,
    height: obj.h - padding * 2
  };

  // Axis-Aligned Bounding Box (AABB) collision check
  const isColliding =
    player.x < objHitbox.x + objHitbox.width &&
    player.x + player.width > objHitbox.x &&
    player.y < objHitbox.y + objHitbox.height &&
    player.y + player.height > objHitbox.y;

  if (isColliding) {
    if (obj.type === 'tech') {
      // Collect loot
      bonusCount = Math.min(bonusCount + 1, 10);
      const points = 100 * bonusCount;
      score += points;
      dimensionHue += 5;

      // Visual + sound feedback
      particles.push(new Particle(obj.x + obj.w/2, obj.y + obj.h/2, '#fff', `+${points}`, 1.3));
      for (let j = 0; j < 10; j++) {
        particles.push(new Particle(
          obj.x + obj.w/2,
          obj.y + obj.h/2,
          `hsl(${dimensionHue}, 100%, 65%)`,
          null,
          0.9
        ));
      }

      gameObjects.splice(i, 1);
      continue; // skip drawing & cleanup for this frame
    } 
    
    else if (obj.type === 'portal') {
      // Zone transition
      flashScreen();

      if (currentZone === 'CYBER') {
        currentZone = 'SNACK';
        gameSpeed = 7;
      } else if (currentZone === 'SNACK') {
        currentZone = 'EARTHQUAKE';
        gameSpeed = 12;
        beastModeSfx.currentTime = 0;
        beastModeSfx.play();
        beastModePlayed = true;
      } else {
        currentZone = 'CYBER';
        gameSpeed = 7;
        beastModePlayed = false;
      }

      bonusCount = 0;
      portalActive = false;
      gameObjects = [];     // clear everything
      particles = [];       // clear particles
      break;                // important: exit loop after reset
    } 
    
    else if (obj.type === 'obstacle') {
      // Hit obstacle â†’ game over
      triggerBSOD();
      // Note: we don't remove the obstacle here so player sees it on BSOD screen
    }
  }

  // Draw the object (if still alive)
  if (obj.img?.complete) {
    ctx.drawImage(obj.img, obj.x, obj.y, obj.w, obj.h);
  }

  // Clean up objects that are way off-screen
  if (obj.x < -150) {
    gameObjects.splice(i, 1);
  }
}

    // UI update
    document.getElementById('score').innerText     = `DIMENSION: ${score}`;
    document.getElementById('highScore').innerText = `BEST: ${highScore}`;
    document.getElementById('status').innerText    = `ZONE: ${currentZone}`;
  }

  ctx.restore();
  requestAnimationFrame(loop);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  INPUT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Remove the generic touchstart listener and use these specific ones
document.getElementById('hardModeBtn').addEventListener('touchstart', e => {
  e.preventDefault();
  e.stopPropagation();
  
  // START CHAOS MODE (Current Page)
  document.getElementById('startOverlay').style.display = 'none';
  resetGame();
  gameState = 'PLAYING';
  bgMusic.play().catch(() => {});
}, {passive: false});

document.getElementById('easyModeBtn').addEventListener('touchstart', e => {
  e.preventDefault();
  e.stopPropagation();
  
  // REDIRECT TO COMFORT MODE PAGE
  // Replace 'comfort.html' with the actual filename of your second page
  window.location.href = 'comfort.html'; 
}, {passive: false});

// Keep the jump logic separate so it only works while playing
window.addEventListener('touchstart', e => {
  // Check if playing and if we have jumps left (allows double jump)
  if (gameState === 'PLAYING' && jumpsUsed < 2) {
    if (!e.target.closest('.btn')) {
      yVelocity = -22; // The power of the jump
      jumpsUsed++;     // Increment so we can't fly forever
      e.preventDefault();
    }
  }
}, {passive: false});


// Start loop
loop();
  if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('sw.js');
}

</script>
</body>
</html>
